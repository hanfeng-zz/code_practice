
---

## 🧩 现象

在 `a.c` 中直接调用 `b.c` 里定义的函数，即使没有在 `a.c` 中使用 `extern` 或 `#include` 头文件声明函数，也能编译成功并运行。

---

## ✅ 成功的原因

1. **编译器使用了旧标准（如 C89/C90）或默认宽松模式**：

   * 编译器在没有看到函数声明时，会**自动假设**它的返回类型是 `int`，参数类型未知。
   * 这称为“**隐式函数声明**”（implicit function declaration）。

2. **链接器在 b.c 中找到了这个函数的定义**：

   * 编译器虽然没看到声明，但目标文件里记录了需要的符号。
   * 链接器把 `a.o` 和 `b.o` 一起链接，成功解决符号引用。

---

## ⚠️ 重要说明

* **C99 及以后的标准（C99、C11、C17、C23）已经禁止隐式函数声明！**
* 如果你用新标准（如 `gcc -std=c99`），编译时会报错：

  ```
  error: implicit declaration of function ‘func_b’ is invalid in C99
  ```

---

## ✅ 推荐做法（始终安全）

1. 在 `b.h` 中声明函数：

   ```c
   void func_b(void);
   ```

2. `a.c` 中使用 `#include "b.h"`：

   ```c
   #include "b.h"
   ```

3. 用标准 C 编译：

   ```bash
   gcc -std=c11 a.c b.c -o app
   ```

---

## 📌 总结表格

| 项目               | 是否允许   | 原因说明       |
| ---------------- | ------ | ---------- |
| 未声明直接调用（C89）     | ✅ 允许   | 编译器默认隐式声明  |
| 未声明直接调用（C99+）    | ❌ 报错   | 隐式声明被禁止    |
| 有声明（extern 或头文件） | ✅ 推荐   | 安全、标准合规    |
| 链接成功但编译器未检查类型匹配  | ⚠️ 有风险 | 可能运行异常或 UB |

---
git
